# 관계형 데이터베이스

수 많은 사용자들에게 효율적인 데이터 관리와 예상치 못한 사건으로 인한 데이터 손상을 막고, 필요하다면 데이터 복구까지 할 수 있는 이런 요구사항을 만족시켜주는 것이 DBMS(Database Management System) 라고 한다.



#### 관계형 데이터베이스(Relational Database)

만약 하나의 파일을 여러 지사에서 복사해 나눠가진 다음, 변경작업을 하면 이 여러 개의 변경된 파일은 결국 데이터의 불 일치성이 생긴다. 그래서 관계형 데이터베이스는 **정규화를 통해 합리적인 테이블 모델링으로 이상현상을 제거하고 많은 사용자들이 동시에 데이터를 공유 또는 조작할 수** 있게 구현 해준다.



## 데이터 무결성과 트랜잭션

> 데이터베이스 시스템은 데이터에 접근하거나 처리할 때마다 부적절한 데이터가 입력되는 지 검사하여 데이터의 결점없음, 무결점을 유지한다.



#### 데이터 무결성의 종류

| 유형            | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| 개체 무결성     | 기본 키(primary key) 로 선택된 열은 고유해야 하고 null 값을 가질 수 없다. |
| 참조 무결성     | 참조하는 왜래 키(FK)가 존재하면 행 삭제 못한다.              |
| 영역 무결성     | 데이터의 형태, 범위, 기본값, 유일성에 관한 제한사항이다.(ex) 값이 0이상) |
| 비즈니스 무결성 | 업무에 따른 제약 조건                                        |



#### 제약 조건

1. 기본 키 제약 조건 : UNIQUE + NOT NULL 둘 다 만족 해야 한다.
2. 왜래 키 제약 조건 : 열 값이 부모 테이블의 참조 열의 값을 반드시 참조해야 한다.
3. 유일 키 : 중복된 값을 허용하지 않는다. 
4. NOT NULL : null 값을 허용하지 않는다.(반드시 값 입력)
5. CHECK : 범위나 조건 등 지정된 값만 허용.



#### 트랜잭션(Transaction)

데이터의 무결성이 보장되는 상태에서 DML 작업을 완수하기 위한 **기본 작업단위**. SELECT 문으로 데이터를 조회하고 DML을 실행하여 종료하는 과정까지를 말한다.



#### 트랜잭션의 특징(ACID)

| 개념   | 내용                                                         |
| ------ | ------------------------------------------------------------ |
| 원자성 | 트랜잭션의 처리가 완전히 끝난게 아니면 전혀 이루어 지지 않은 것과 같다. |
| 일관성 | 일관성이 보존된 상태                                         |
| 고립성 | 다른 트랜잭션의 부분적 실행결과를 볼 수 없다.                |
| 지속성 | 트랜잭션 성공하면, 결과를 영구적으로 보장해야한다.           |

1. 원자성 : 계좌이체 실패하면 안 한 것과 같다.
2. 일관성 :  A계좌 10만원 출금 == B계좌 10만원 입금
3. 고립성 : A계좌가 이체 완료 된 것이 아니면, B는 관여 못한다.
4. 보존성 : 계좌이체 성공 시, 결과 보장한다.



#### 트랜잭션의 수행 단계

| 상태                           | 설명                                        |
| ------------------------------ | ------------------------------------------- |
| 실행(active)                   | 트랜잭션을 실행 중                          |
| 부분 완료(partially committed) | DML등의 트랜잭션 명령 실행한 후 상태        |
| 완료(committed)                | 트랜잭션 성공적으로 완료                    |
| 실패(failed)                   | 더 이상 정상적으로 실행될 수 없음           |
| 철회(aborted== 롤백)           | 트랜잭션이 복원되어 수행 이전 상태로 돌아감 |



#### 트랜잭션 제어어(TCL, Transaction Control Language)

| 개념      | 설명                                                         |
| --------- | ------------------------------------------------------------ |
| 커밋      | 트랜잭션의 모든 미결정 데이터를 영구적으로 반영              |
| 롤백      | 트랜잭션의 모든 미결정 데이터 변경을 포기                    |
| SavePoint | 저장점(SP)를 정의하면 롤백 할 때 전체 작업을 롤백 하는게 아니라 (SP<->현재) 구간만 롤백할 수 있다. |

- 예제 (`행 입력`,  `수정`, `삭제`)

  1. 커밋: `메모리 BUFFER에만 영향을 받았기 때문에 데이터의 변경 이전 상태로 복구 가능하다. `

     ```sql
     # 예제 1 (행 만들기)
     INSERT INTO PLAYER (PLAYER_ID, TEAM_ID, PLAYER_NAME, 
                         POSITION, HEIGHT, WEIGHT, BACK_NO) 
     VALUES ('1999035', 'K02', '이운재', 'GK', 182, 82, 1);
     
     # 커밋 실행
     COMMIT;
     ```

     ```SQL
     # 예제 2 (수정)
     UPDATE PLAYER SET HEIGHT = 100;
     
     # 커밋 실행
     COMMIT;
     ```

     ```SQL
     # 예제 3 (삭제)
     DELETE FROM PLAYER;
     
     # 커밋 실행
     COMMIT;
     ```

     > 테이블 명과 칼럼의 데이터를 [입력,수정,삭제] 하고 커밋까지 실행한다.

     

  2. 롤백: 

     ```sql
     # 예제 1 (행 만들기)
     INSERT INTO PLAYER (PLAYER_ID, TEAM_ID, PLAYER_NAME, 
                         POSITION, HEIGHT, WEIGHT, BACK_NO) 
     VALUES ('1999035', 'K02', '이운재', 'GK', 182, 82, 1);
     
     # 롤백 실행
     ROLLBACK;
     ```

     ```SQL
     # 예제 2 (수정)
     UPDATE PLAYER SET HEIGHT = 100;
     
     # 롤백 실행
     ROLLBACK;
     ```

     ```SQL
     # 예제 3 (삭제)
     DELETE FROM PLAYER;
     
     # 롤백 실행
     ROLLBACK;
     ```

     - `ROLLBACK` 후의 데이터 상태는
       1. 데이터에 대한 변경사항은 취소
       2. 이전 데이터는 다시 저장
       3. 관련 행에 대한 잠금(LOCKING)이 풀리고 다른사용자들이 행 조작 가능

  3. 저장점 SAVE POINT

     예제를 통해 `저장점` 을 지정하고 데이터를 [입력, 삭제, 수정] 하며 저장점을 실행해보자

     ```SQL
     # 저장점 생성
     SAVEPOINT SVPT1;
     
     # 행 입력
     INSERT INTO PLAYER (PLAYER_ID, TEAM_ID, PLAYER_NAME, 
                         POSITION, HEIGHT, WEIGHT, BACK_NO) 
     VALUES ('1999035', 'K02', '이운재', 'GK', 182, 82, 1);
     
     # 롤백 실행
     ROLLBACK TO SVPT1;
     ```

     ```SQL
     # 저장점 생성
     SAVEPOINT SVPT2;
     
     # 행 수정
     UPDATE PLAYER SET WEIGHT = 100;
     
     # 롤백 실행
     ROLLBACK TO SVPT2;
     ```

     ```SQL
     # 저장점 생성
     SAVEPOINT SVPT3;
     
     # 행 삭제
     DELETE FROM PLAYER;
     
     # 롤백 실행
     ROLLBACK TO SVPT3;
     ```

     

## 결론

테이블의 데이터를 변경시키는 [입력, 수정, 삭제] 명령어를 수행할 때, `무결성` 을 보장하는 것이 

`트랜잭션 제어어 TCL` (커밋, 롤백, 저장점) 이다. 

#### 주의할 점

1. **DDL 문장**(CREATE, ALTER, DROP, RENAME, TRUNCATE TABLE)을 실행할 땐 그 전후 시점으로 **자동커밋**된다.
2. 데이터베이스를 정상적으로 다루고 접속을 종료하면 자동으로 트랜잭션이 커밋된다.
3. 어플이 이상하게 종료되면 트랜잭션은 자동 롤백된다.