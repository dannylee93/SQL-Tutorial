# SQL - Optimizer

> 옵티마이저는 사용자가 질의한 SQL문에 대해 최적의 실행 방법을 결정하는 역할을 수행한다. 이 최적의 실행 방법을 실행계획(Execution Plan)이라고 한다. 



### 옵티마이저는..

관계형 데이터베이스는 옵티마이저가 결정한 실행 방법대로 실행 엔진이 데이터를 처리하여 결과 데이터를 사용자에게 전달할 뿐이다. 옵티마이저가 선택한 실행 방법의 적절성 여부는 질의의 수행 속도에 가장 큰 영향 미치게 된다.

 ![sql가이드](http://www.dbguide.net/publishing/img/knowledge/SQL_239.jpg)

> 최적의 실행 방법을 결정하는 방식에 따라 [그림 Ⅱ-3-1]과 같이 규칙기반 옵티마이저(RBO, Rule Based Optimizer)와 비용기반 옵티마이저(CBO, Cost Based Optimizer)로 구분할 수 있다.



### (1) 규칙 기반 옵티마이저

규칙 기반 옵티마이저에서 `규칙`이란 **우선 순위** 를 말한다. 이 규칙을 가지고 실행계획을 생성한다.

규칙기반 옵티마이저는 **우선 순위가 높은 규칙이 적은 일량**으로 해당 작업을 수행하는 방법이라고 판단하는 것이다.

![sql가이드](http://www.dbguide.net/publishing/img/knowledge/SQL_240.jpg)

> 위의 표는 Oracle의 규칙기반 옵티마이저의 15가지 규칙이다. 순위의 숫자가 낮을수록 높은 우선 순위이다.

1. `Single row by rowid` : 

   ROW-ID를 통해서 테이블에서 **하나의 행을 액세스**하는 방식이다. ROW-ID는 행이 포함된 데이터 파일, 블록 등의 정보를 가지고 있기 때문에 다른 정보를 참조하지 않고도 바로 원하는 행을 액세스할 수 있다. 하나의 행을 액세스하는 가장 빠른 방법이다.

4. `Single row by unique or primary key` : 

   **유일 인덱스(Unique Index)**를 통해서 **하나의 행을 액세스**하는 방식이다. 이 방식은 인덱스를 먼저 액세스하고 인덱스에 존재하는 ROWID를 추출하여 테이블의 행을 액세스한다.

8. `Composite index` : 

   **복합 인덱스**에 **동등(‘=’ 연산자) 조건으로 검색**하는 경우이다. 

   예를 들어, 만약 A+B 칼럼으로 복합 인덱스가 생성되어 있고, 조건절에서 WHERE A=10 AND B=1 형태로 검색하는 방식이다. 복합 인덱스 사이의 우선 순위 규칙은 다음과 같다. 인덱스 구성 칼럼의 개수가 더 많고 해당 인덱스의 모든 구성 칼럼에 대해 ‘=’로 값이 주어질 수록 우선순위가 더 높다. 예를 들어, A+B로 구성된 인덱스와 A+B+C로 구성된 인덱스가 각각 존재하고 조건절에서 A, B, C 칼럼 모두에 대해 ‘=’로 값이 주어진다면 A+B+C 인덱스가 우선 순위가 높다. 만약 조건절에서 A, B 칼럼에만 ‘=’로 값이 주어진다면 A+B는 인덱스의 모든 구성 칼럼에 대해 값이 주어지고 A+B+C 인덱스 입장에서는 인덱스의 일부 칼럼에 대해서만 값이 주어졌기 때문에 A+B 인덱스가 우선 순위가 높게 된다.

9. `Single column index` : 

   **단일 칼럼 인덱스**에 `=` 조건으로 검색하는 경우이다. 만약 A 칼럼에 단일 칼럼 인덱스가 생성되어 있고, 조건절에서 A=10 형태로 검색하는 방식이다.

10. `Bounded range search on indexed columns` : 

    인덱스가 생성되어 있는 칼럼에 **양쪽 범위를 한정하는 형태로 검색**하는 방식이다. 이러한 연산자에는 `BETWEEN`, `LIKE` 등이 있다. 만약 A 칼럼에 인덱스가 생성되어 있고, A BETWEEN ‘10’ AND ‘20’ 또는 A LIKE '1%' 형태로 검색하는 방식이다.

11. `Unbounded range search on indexed columns` : 

    인덱스가 생성되어 있는 칼럼에 **한쪽 범위만 한정하는 형태로 검색**하는 방식이다. 이러한 연산자에는 `>, >=, <, <=` 등이 있다. 만약 A 칼럼에 인덱스가 생성되어 있고, `A > '10'` 또는 `A < '20'` 형태로 검색하는 방식이다.

15. `Full table scan` : 

    **전체 테이블을 액세스**하면서 조건절에 **주어진 조건**을 만족하는 행만을 결과로 추출한다.

#### 주의사항

인덱스를 이용한 액세스 방식이 전체 테이블 액세스 방식보다 우선순위가 높다. 따라서 SQL을 사용할 때 쓸 수 있는 인덱스가 존재하면 전체 테이블 액세스 방식보다 항상 인덱스를 사용하는 실행계획을 생성한다.

#### 최적화 과정

```sql
SELECT ENAME 
FROM EMP
WHERE JOB = 'SALESMAN' AND SAL BETWEEN 3000 AND 6000 

INDEX --------------------------------- EMP_JOB : JOB EMP_SAL : SAL PK_EMP : EMPNO (UNIQUE)
```

- 조건절에서 JOB 칼럼의 조건은 ‘=’, SAL 칼럼의 조건은 ‘BETWEEN’으로
- 우선 순위 규칙에 따라 JOB 조건은 규칙 9의 단일 칼럼 인덱스를 만족
- SAL 조건은 규칙 10의 인덱스상의 양쪽 한정 검색을 만족한다.
- 따라서 우선 순위가 높은 EMP_JOB 인덱스를 이용해서 조건을 만족하는 행에 대해 EMP 테이블을 액세스하는 방식을 선택할 것이다.

```
Execution Plan ------------------------------------------------------------ SELECT STATEMENT Optimizer=CHOOSE TABLE ACCESS (BY INDEX ROWID) OF 'EMP' INDEX (RANGE SCAN) OF 'EMP_JOB' (NON-UNIQUE)
```

> 규칙기반 옵티마이저가 생성한 실행계획이다.



### (2) 비용 기반 옵티마이저

단순한 몇 개의 규칙만으로 현실의 모든 사항을 정확히 예측할 수는 없다. 비용기반 옵티마이저는 이러한 규칙기반 옵티마이저의 단점을 극복하기 위해서 출현하였다.

비용기반 옵티마이저는 SQL문을 **처리하는데 필요한 비용이 가장 적은** 실행계획을 선택하는 방식이다.

여기서 비용이란 SQL문을 처리하기 위해 예상되는 **소요시간** 또는 **자원 사용량**을 의미한다.

![sql가이드](http://www.dbguide.net/publishing/img/knowledge/SQL_241.jpg)

> 비용기반 옵티마이저는 질의 변환기, 대안 계획 생성기, 비용 예측기 등의 모듈로 구성되어 있다.

- `대안 계획 생성기` : 동일한 결과를 생성하는 다양한 대안 계획을 생성하는 모듈.

  대안 계획은 연산의 **적용 순서 변경**, **연산 방법 변경**, **조인 순서 변경** 등을 통해서 생성된다. 즉, 대안 계획을 세우는 시간이 너무 많아지지 않는 선에서 다양한 방법을 구사하자는 말

- `비용 예측기` : 대안 계획 생성기에 의해서 생성된 대안 계획의 비용을 예측하는 모듈.

  -  대안 계획의 정확한 비용을 예측하기 위해서 연산의 중간 집합의 크기 및 결과 집합의 크기, 분포도 등의 예측이 정확해야 한다.

- 비용기반 옵티마이저는 인덱스를 사용하는 비용이 전체 테이블 스캔 비용보다 크다고 판단되면 전체 테이블 스캔을 수행하는 방법으로 실행계획을 생성할 수도 있다.